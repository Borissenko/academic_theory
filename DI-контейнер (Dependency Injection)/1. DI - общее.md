# 
## Inversion of Control (инверсия управления) 
— это некий абстрактный принцип, набор рекомендаций для написания слабо связанного кода. 
Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других, не полагаясь в своей работе на детали конкретной реализации других компонентов.

## Dependency Injection (внедрение зависимостей) 
— это одна из реализаций этого принципа (помимо этого есть еще Factory Method, Service Locator).

## IoC-контейнер 
— это какая-то библиотека, фреймворк, программа если хотите, которая позволит вам упростить и автоматизировать написание кода с использованием данного подхода на столько, на сколько это возможно. Их довольно много



Внедрение зависимости — процесс предоставления внешней зависимости программному компоненту. 
Является специфичной формой «инверсии управления» (Inversion of control, IoC), 
когда она применяется к управлению зависимостями. 
В полном соответствии с принципом единственной обязанности объект отдаёт заботу о построении требуемых ему зависимостей 
внешнему, специально предназначенному для этого общему механизму.


# Способы DI
Есть два основных способа внедрения зависимостей:

## Constructor Injection (инъекция конструктора). 
- передаем зависимость через аргументы в момент генерации экземпляра

class Car(private engine: Engine) {
  start() {
    engine.start()
  }
}

function main(args: Array) {
  val car = Car(Engine())     <<<<
  car.start()
}


## Field Injection (или Setter Injection, полевая инъекция)
- зависимость добавляем в ГОТОВЫЙ ЭКЗЕМПЛЯР, а не при запуске класса.
class Car {
   engine: Engine
   fun start() {
      engine.start()
    }
}

function main(args: Array) {
  val car = Car()
  car.engine = Engine()     <<< А лучше - присуждать через сеттеры.
  car.start()
}