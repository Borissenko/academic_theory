# Определение правила Liskov
- что относиться к типу должно быть справедливым и для подтипа.
- функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Т.е. ПОДТИП может ЗАМЕНИТЬ в коде БАЗИСНЫЙ ТИП без ущерба.
для этого подтип должен дополнять, а НЕ изменять базовый.
Приемственность подтипа должна сохраняться.

РЕШЕНИЕ
- создаем Квадрат и Прямоугольник от общей абстракции,
- а не квадрат от прямоугольника.

## Предварительные условия(арргументы) не могут быть усилены в подтипе.
## Постусловия(условия для реализыции return'a) не могут быть ослаблены в подтипе.
## Инварианты супертипа могут быть сохранены в подтипе.


# Определение 'предусловие' и 'постусловие'.
= метод не начнёт свою работу, если какое-то из предусловий будет нарушено,
= метод не вернёт результат, если будет нарушено постусловие. 
В подобном случае, например, генерируем ошибку throw Error.




#  Описание проблемы
Моделируя систему, мы описываем поведение её компонентов, отношения их друг с другом, 
а не иерархию. 
Иерархия — удобный инструмент для моделирования, 
но иногда она приводит к неправильному описанию поведения.

Поэтому проектируя не стоит полностью копировать иерархию объектов из реального мира.


# Пример неувязки
Разница между квадратом и прямоугольником в том, 
что у квадрата при изменении стороны меняются сразу обе стороны, 
у прямоугольника — только одна, а вторая остаётся неизменной.

Используя ПОДТИП Квадрат для обсчета прямоугольника, который здесь будет базисным случаем,
мы получим неувязку.


# Мораль
— классы-наследники не должны противоречить базовому классу. 
Например, они не могут предоставлять интерфейс, который ýже базового.


# Способ решения
Не наследуем Квадрат от Прямоугольника,
а создаем общий АБСТРАКТНЫЙ класс (в котором поля просто декларированы, без присуждения значения).
Или создаем базовый интерфейс.
И создаем Квадрат и Прямоугольник от общей абстракции.

Здесь подклассы будут или вбирать поля базового "как есть",
или перетирать их, но уже с конкретным кодом, с инициализацией.

abstract class Disposable {
  protected source: Optional<number>
  constructor(fn: AnyFunction, delay: TimeIntervalMS) {}

  doIt(): void {}
}


# Где это можно использовать
- выделять общую для нескольких модулей функциональность в общий интерфейс




