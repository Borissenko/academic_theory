# Dependency Inversion Principle
- заменить композицию агрегацией

# Суть проста: 
- заменить композицию агрегацией,  <<< ДА(!)
а точку входа у акцептора ТИПИРОВАТЬ интерфейсом, 
а не конкретным безальтернативным экземпляром донора.

Т.е. оружие получать в АРГУМЕНТАХ, а не жестко декларируя его внутри модуля.
При этом типируем одним и тем же интерфейсом 
и аргумент у модуля (точка акцепции), и когда на стороне создаем этот экземпляр оружия,

а не напрямую, минуя интерфейс, типируем точку акцепции  
жестко и БЕЗАЛЬТЕРНАТИВНО указанным конкретным ИМЕННЫМ внешним экземпляром,
вставляя его как ЭКСПОРТИРУЕМЫЙ блок.
 
Вот и все.

В таком случае можно без правок в акцепторе поставлять ему РАЗЛИЧНОЕ оружие,
или, не боясь выйти из соответствия с акцептором, модифицировать оружие, 
главное, что бы оружие продолжало соответствовать интерфейсу.


# Лучше пользоваться кем-то,
# чем самому обладать своей аналогичной ЛИЧНОЙ способностью. (!)

Не работать с экземплярами классов напрямую, которые создаются внутри тебя,
а получать экземпляры нужных классов ИЗ-ВНЕ,
например, через аргументы функции.



# Это будет выглядеть так:
let dd = new Car(new Engine())

