# Dependency Inversion Principle
- заменить типирование аргументов литералом на типирование интерфейсом/type.

- заменить композицию агрегацией(нет).

{}-аргумент у акцептора - ТИПИРОВАТЬ, 
причем типировать ПОЛИВАЛЕНТНЫМ интерфейсом, 
а НЕ КОНКРЕТНЫМ безальтернативным литералом, по типу которого поставляется донор.

Т.е. оружие получать в АРГУМЕНТАХ, а не жестко прописывая его внутри модуля.
При этом типируем определенным интерфейсом:
и аргумент у модуля (точка акцепции), 
и создаваемый снаружи экземпляр оружия.

а не напрямую, минуя интерфейс, типируем точку акцепции  
жестко и БЕЗАЛЬТЕРНАТИВНО указанным конкретным ИМЕННЫМ внешним экземпляром,
вставляя его как ЭКСПОРТИРУЕМЫЙ блок.
 
Вот и все.

В таком случае можно без правок в акцепторе мы можем поставлять ему РАЗЛИЧНОЕ оружие,
или, не боясь выйти из соответствия с акцептором, модифицировать оружие, 
главное, что бы оружие продолжало соответствовать интерфейсу.


# Лучше пользоваться кем-то,
# чем самому обладать своей аналогичной ЛИЧНОЙ способностью. (!)

Не работать с экземплярами классов, которые создаются внутри тебя, жестко прописывая их внутри модуля,
а получать экземпляры нужных классов(агрегация) или классы(композиция) - ИЗ-ВНЕ,
через аргументы.



# Это будет выглядеть так:
let dd = new Car(new Engine())   - via агрегация
let dd = new Car(Engine)         - via композиция

