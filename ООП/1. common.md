
# Принципы декларации класса
## 1. Single Responsibility Principle / Принцип единственной ответственности / 
Первый принцип SOLID
## 2. Ассоциация c иным объектом.


# Ассоциация c иным объектом.
- добавление ЭКЗЕМПЛЯРА другого класса в роли поля нашего класса.
Это НЕ наследование. 
Здесь в роли поля зкземпляра будет выступать сгенерированный экземпляр от другого класса.

Ассоциация бывает двух видов,
причем композиция - это частный случай агрегации(Да!):
1. optimus = new Transformer(Gun)      <<< Композиция.
  или

2. let myGun = new Gun()
   optimus = new Transformer(myGun)     <<< Агрегация.
   optimus = new Transformer(new Gun()) <<< Агрегация.
   optimus = new Transformer()          <<< Агрегация.

class Transformer(){ 
    gun1
    constructor(gun){
        this.gun1 = new gun   //генерируем пушку при создании экземпляра Трансформера, Композиция.
        this.gun1 = gun       //устанавливаем пушку, взятую из-вне, на борт, Агрегация.
    }

    fire(){
        this.gun1.fire()
    }
}



## 1. Композиция
> жизненный цикл дочернего объекта совпадает с жизненным циклом родительского. 
(Да. Это исчерпывающее определение.)
- композиция - это частный случай агрегации(Да!).

- экземпляр от другого класса генерируется в конструкторе.
Здесь аргумент gun - это class Gun

— случай, когда на фабрике трансформеров, собирая Оптимуса, 
обе пушки ему намертво приколачивают к рукам гвоздями, 
и после смерти Оптимуса, пушки умирают вместе с ним. 
Другими словами, 
- «части» не могут существовать отдельно от «целого»



## 2. Агрегация:
> жизненный цикл донора не зависит от жизненного цикла акцептора,
и может использоваться другими объектами.
- экземпляр от другого класса генерируется снаружи, и полученный его экземпляр
передается в конструктор. 

## 2а. Агрегация через аргументы конструктора.
let myGun = new Gun()
optimus = new Transformer(myGun)

— случай, когда пушка выдается как пистолет в руку, 
и после смерти Оптимуса этот пистолет может подобрать его боевой товарищ Олег.


## 2b. Агрегация через сеттеры.
- осуществляется через методы уже созданного экземпляра,
в классе прописываем сеттер, который загоняет в класс внешнюю сущьность.

class Car {
  feature

  set setFeature(feature) {
    this.feature = feature
  }

  get getFeature() {
    return this.feature
  }
}


## 2с. Агрегация, встроенная в значение по-умолчанию у класса-акцептора.
- донор-экземпляр генерируется в момент создания экземпляра акцептора.

class Transformer {
  contract: IContract

  constructor(contract: IContract = new Contract()) {     << подставляем как значение по-умолчанию.
    this.contract = contract
  }
}
optimus_K = new Transformer()




## 3. Также есть термины о взаимоотношениях:
## 3a. зависимость (dependency) — изменение в одной сущности (независимой) 
может влиять на состояние или поведение другой сущности (зависимой)

## 3b. обобщение (generalization) — отношение наследования или реализации интерфейса. 
Со стороны стрелки находится суперкласс или интерфейс.






# ООП
## наследование
## полиморфизм
## инкапсуляция

Если с помощью классов мы не задействуем полиморфизм, композицию и наследование, 
а вместо этого применяем классы лишь для группировки функций и данных, 
то это не ООП.



# 1. НАСЛЕДОВАНИЕ
На деле же принцип "наследование" не столько о непосредственно наследовании, 
сколько об абстрагировании и разделении ответственностей.
Здесь лучше "наследовать" КОМПОЗИЦИЕЙ(!), а не классическим наследованием.(см ниже)

Классически - экземпляр генерируем от более ЧАСТНОГО класса, 
а в него добавляем св-ва общего класса.
Здесь ДОЧЕРНИЙ класс принимает в себя общий класс.

## конфликт с SOLID-3
Но это НАРУШАЕТ  принцип подстановки Барбары Лисков SOLID(!).
"ПОДТИП может ЗАМЕНИТЬ в коде БАЗИСНЫЙ ТИП без ущерба"

## Поля акцептора перетирают поля донора.
В момент вызова метода или обращения к полю экземпляра, 
поиск атрибута происходит сначало в классе-акцепторе, который мы вызываем через new, 
и лишь затем в акцептированном общем классе.





## = Ассоциация (Композиция, Агрегация) vs Наследования.
### 1. Где Наследование - уместно.
Например, чайник с таймером должен наследоваться от чайника или от таймера?
Хороший ответ — от того и от другого (т.е. множественное наследование).
Правильный ответ — наследованию стоит предпочесть композицию. Хотя это технически трудно.

> Наследование - для последующего наращивания ПОЛЕЙ, количественно. Расширение возможностей.
> Ассоциация - для МОДИФИКАЦИИ имеющихся полей качественно. Пластичность.

> Если получается оч длинная цепочка наследований,
или когда хотим унаследовать только часть общего класса,
то лучше использовать КОМПОЗИЦИЮ, а не наследование.

Преимущество композиции от наследования — в более высокой абстрактности.

NO: Животные → Млекопитающие → Человек.    << это Наследование. Конфликт с SOLID-3.

YES: Человек = ССС + НС + скелет           << это Композиция. Конфликта с SOLID-3 нет.
1/ type User_1 = ССС & NC & Skelet
2/ class User_2 extends BaseUser implements UserWithAccess, UserWithProfile { }



### 2. статичность наследования.
- наследование статично, а композиция может быть разной для разных экземпляров. 

Композиция - это когда жизненный цикл дочернего объекта 
совпадает с жизненным циклом родительского,
и НЕ изменяемо в течении жизни только ДАННОГО экземпляра.


### 3. Множественное наследование совсем плохо.
т.е. когда вбираем в себя несколько "общих" классов.
Его лучше избегать, а взамен применять механизм интерфейсов. (см ниже)
class User_2 extends BaseUser implements UserWithAccess, UserWithProfile { }



## Абстрактные классы
- от них непосредственно экземпляры не генерируем.
Они созданы что бы их наследовал кто-то в роли базисного класса.

В него часто записывают методы без кода, а поля без значений,
что бы напомнить программисту, каие методы он должен описать в частном потомке. 



  


# 2. ПОЛИМОРФИЗМ 
— свойство системы, позволяющее иметь множество реализаций какого-либо действия.
- подкласс способен вызвать УНАСЛЕДОВАННУЮ common-функцию класса, 
но В СВОЕМ собственном подклассном КОНТЕКСТЕ.

задача - просто вызвать метод attack(), не загоняясь о деталях,
а каким способом будет атокавать именнно этот экземпляр - зависит от полей экземпляра.

Чтобы это произошло полиморфизм использует наследование(!, да).
После создания экземпляра запускаем какой-либо его метод car1.go(),
сама функция go() описана в абстрактном доноре,
а аргументы-значения полей экземпляра(!), поступающие в функцию via this(!),
индивидуализируют результаты работы функции применительно к состоянию данного экземпляра.

class Record {
  constructor(amount, type) {
    this.amount = amount
    this.type = type
  }
}

const spending = new Record(400, "spending")  //<< за счет ДОБАВЛЕНИЯ АРГУМЕНТА "Вид_траты"(!) мы достигаем полиморфизм.
const income = new Record(400, "income")

Эту же проблему можно решить с помощью наследования, 
но НАСЛЕДОВАНИЕ лучше НЕ использовать(!).
Но можно использовать TS интерфейсы.



# 3. ИНКАПСУЛЯЦИЯ
— это контроль доступа к полям и методам объекта.
Под контролем доступа подразумевается не только можно/неможно, 
но и различные валидации, подгрузки, вычисления и прочее динамическое поведение.
- объединяем данные и методы в классе.


## publiс, protected, private поля TS. 
public — к атрибуту может получить доступ любой желающий
protected - доступ только из методов самого класса и его наследников, и в их конструкторах.
private (самый жесткий) - доступен только из методов ДАННОГО класса и в его конструкторе.

## Аксессоры (геттеры и сеттеры)
геттер - с запросом результата из кэша (меморизация),
сеттер с валидацией перед присвоением

class Car {
  get age() {
    return this.amount
  }
  set age(nn) {
    this.#myAge = nn
  }
}

## Замыкания




# Интерфейсы TS.
- таже цель, что и у абстрактных классов. 
является не классом, а просто пустышкой с перечислением абстрактных методов 
(без имплементации, без конкретного кода в методе. Просто обозначаем наличие этого метода).

interface IMy{
  function fire() {}     // декларация метода БЕЗ имплементации. 
}

class Car(): IMy {
  function fire(){
    ...                 // имплементация, т.е. прописываем конкретный код
  }
}



## SOLID-4
ISP (Interface Segregation Principle / Принцип разделения интерфейса) 
призывает не создавать жирные универсальные интерфейсы. 
Вместо этого интерфейсы нужно разделять на более мелкие и специализированные, 
это поможет гибче их комбинировать в имплементирующих классах, 
не заставляя имплементировать лишние методы.



# Абстракции - почти четвертый остов ООП.
Но уместное количество абстрактных слоев порой трудно обозначить. ))

``


# Ресурсы
https://habr.com/ru/post/463125/
https://habr.com/ru/post/136766/

https://doka.guide/js/oop
https://ota-solid.vercel.app/lsp/antipatterns
https://refactoring.guru/ru/design-patterns/state

