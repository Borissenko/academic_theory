

# Принципы декларации класса
## 1. Single Responsibility Principle / Принцип единственной ответственности / 
Первый принцип SOLID


## 2. Ассоциация c иным объектом.
- добавление ЭКЗЕМПЛЯРА другого класса в роли поля для нашего класса.
Это НЕ наследование. 
Здесь в роли поля зкземпляра будет выступать сгенерированный экземпляр от другого класса.

class Transformer(){ 
    gun1
    function constructor(gun){
        this.gun1 = gun   // устанавливаем пушку на борт
        this.gun1 = new gun
    }

    function fire(){
        this.gun1.fire()
    }
}

optimus = new Transformer(Gun)        <<< Композиция
optimus = new Transformer(new Gun())  <<< Агрегация

# Ассоциация 
- бывает двух видов:
## 1. Композиция
- экземпляр от другого класса генерируется в конструкторе.
Здесь gun - это class Gun

— случай, когда на фабрике трансформеров, собирая Оптимуса, 
обе пушки ему намертво приколачивают к рукам гвоздями, 
и после смерти Оптимуса, пушки умирают вместе с ним. 
Другими словами, жизненный цикл дочернего объекта совпадает с жизненным циклом родительского.

- «части» не могут существовать отдельно от «целого»

## 2. Агрегация
- экземпляр от другого класса генерируется снаружи, и полученный его экземпляр
передается в конструктор. 

### Агрегация через аргументы класса
-осуществляется в момент создания экземпляра.
-передавать можно способом как значение аргумента конструктора класса "по-умолчанию".

— случай, когда пушка выдается как пистолет в руку, 
и после смерти Оптимуса этот пистолет может подобрать его боевой товарищ Олег, 
а затем взять в свою руку, либо сдать в ломбард. 
То бишь жизненный цикл дочернего объекта не зависит от жизненного цикла родительского, 
и может использоваться другими объектами.

связь «часть»–«целое», в котором «часть» может существовать отдельно от «целого»


### Агрегация через сеттеры
- осуществляется через методы уже созданного экземпляра,
в классе прописываем сеттер, который загоняет в класс внешнюю сущьность.

class Car {
  feature: {}

  set setFeature(feature) {
    this.feature = feature
  }

  get getFeature() {
    return this.feature
  }
}




## Также есть термины о взаимоотношениях
- зависимость (dependency) — изменение в одной сущности (независимой) 
может влиять на состояние или поведение другой сущности (зависимой)

- обобщение (generalization) — отношение наследования или реализации интерфейса. 
Со стороны стрелки находится суперкласс или интерфейс.



.......
# Ассоциация: Агрегация и Композиция
## Ассоциация
– это когда один класс включает в себя другой класс в качестве одного из полей
Выделяют два вида ассоциации:
- композицию и
- агрегацию.

## Агрегация
– это когда экземпляр двигателя создается где-то в другом месте кода,
и передается в конструктор автомобиля в качестве параметра.

## Композиция
– это когда двигатель не существует отдельно от автомобиля.
Он создается при создании автомобиля и полностью управляется автомобилем.
В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.


optimus_A = new Transformer(new Gun())  <<< Агрегация
optimus_K = new Transformer(Gun) и далее new Gun() запускается ВНУТРИ Transformer'a    <<< Композиция-1


class Transformer {
  contract: IContract

  constructor(contract: IContract = new Contract()) {   << подставляем в значение по-умолчанию, Композиция-2.
    this.contract = contract
  }
}
optimus_K = new Transformer()        <<< Композиция-2, но с возможностью наслоения агрегацией.

......




# ООП
## наследование
## полиморфизм
## инкапсуляция

Если с помощью классов мы не задействуем полиморфизм, композицию, наследование и т. д., 
а вместо этого применяете классы лишь для группировки функций и данных, 
то это не ООП.

# 1. НАСЛЕДОВАНИЕ
На деле же принцип "наследование" не столько о непосредственно наследовании, 
сколько об абстрагировании и разделении ответственностей.
Здесь лучше "наследовать" КОМПОЗИЦИЕЙ(!).

(!)Вызываем - более ЧАСТНЫЙ класс, а в него добавляем св-ва общего класса.
Здесь ДОЧЕРНИЙ класс принимает в себя общий класс.


## Поля акцептора перетирают поля донора.
В момент вызова метода или обращения к полю объекта, 
поиск атрибута происходит сначало в классе-акцепторе, который мы вызываем через new, 
и лишь затем в акцептированном общем классе.

### SOLID-3
Но это НАРУШАЕТ  принцип подстановки Барбары Лисков SOLID(!).

Поэтому основным классом, вбирающим дополнительные свойства от другого класса,
должен быть ОБЩИЙ  класс, а не класс с частностями (мое). НЕТ, это не верно.
См. SOLID-5.


## = Ассоциация (Композиция, Агрегация) vs наследования.
Например, чайник с таймером должен наследоваться от чайника или от таймера?
Хороший ответ — от того и от другого (a.k.a множественное наследование).
Правильный ответ — наследованию стоит предпочесть композицию. Хотя это технически трудно.

> Наследование - для последующего наращивания полей количественно. Расширение возможностей.
> Ассоциация - для трансформации имеющихся полей качественно. Кубики.

### Если получается оч длинная цепочка наследований,
а точнее, когда хотим унаследовать только часть общего класса,
то лучше использовать КОМПОЗИЦИЮ, а не наследование.

Преимущество композиции от наследования — в более высокой абстрактности.

NO: Животные → Млекопитающие → Человек.
YES: Человек = ССС + НС + скелет           //это композиция.

1/ type SquareShape = ССС & NC & Skelet
2/ class RegularUser extends BaseUser implements UserWithAccess, UserWithProfile { }



### Второе отличие композиции от наследования - 
наследование статично, а композиция может изменяться динамачески.

Композиция - это когда жизненный цикл дочернего объекта 
совпадает с жизненным циклом родительского 
и НЕ изменяемо в течении жизни экземпляра.






## Множественное наследование
т.е. вбираем в себя несколько "общих" классов.
Его лучше избегать, а взамен применять механизм интерфейсов. (см ниже)



## Абстрактные классы
- от них непосредственно экземпляры не генерируем.
Они созданы что бы их наследовал кто-то в роли базисного класса.

В него часто записывают методы без кода, а поля без значений,
что бы напомнить программисту, каие методы он должен описать в частном потомке. 






# 2. ПОЛИМОРФИЗМ 
— свойство системы, позволяющее иметь множество реализаций одного интерфейса(команды, действия).
- подкласс может вызвать УНАСЛЕДОВАННУЮ common-функцию класса, 
но В СВОЕМ собственном подклассном КОНТЕКСТЕ.

задача - просто вызвать метод attack(), не загоняясь о деталях,
а каким способом будет атокавать именнно этот экземпляр - зависит от полей экземпляра.

Чтобы это произошло полиморфизм использует наследование(!, да).
После создания экземпляра запускаем какой-либо его метод car1.go(),
сама функция go() описана в абстрактном доноре,
а аргументы-значения полей экземпляра(!), поступающие в функцию via this(!),
индивидуализируют результаты работы функции применительно к состоянию данного экземпляра.

class Record {
  constructor(amount, type) {
    this.amount = amount
    this.type = type
  }
}

const spending = new Record(400, "spending")  //<< за счет ДОБАВЛЕНИЯ АРГУМЕНТА "Вид_траты"(!) мы достигаем полиморфизм.
const income = new Record(400, "income")

Эту же проблему можно решить с помощью наследования, 
но НАСЛЕДОВАНИЕ лучше НЕ использовать(!).
Но можно использовать TS интерфейсы.



# 3. ИНКАПСУЛЯЦИЯ
— это контроль доступа к полям и методам объекта.
Под контролем доступа подразумевается не только можно/неможно, 
но и различные валидации, подгрузки, вычисления и прочее динамическое поведение.
- объединяем данные и методы в классе.


## publiс, private, protected поля. 
Как у class в TS:
publiс — к атрибуту может получить доступ любой желающий
private — к атрибуту могут обращаться только методы данного класса.
protected — то же, что и private, только доступ получают и наследники класса в том числе,
но не экземпляры наследника (Нр: acceptor1.voice).


## Аксессоры (геттеры и сеттеры)
геттер - с запросом результата из кэша (меморизация),
сеттер с валидацией перед присвоением

class Car {
  get age() {
    return this.amount
  }
  set age(nn) {
    this.#myAge = nn
  }
}

## Замыкания




# Интерфейсы TS.
- таже цель, что и у абстрактных классов. 
является не классом, а просто пустышкой с перечислением абстрактных методов 
(без имплементации, без конкретного кода в методе. Просто обозначаем наличие этого метода).

interface IMy{
  function fire() {}     // декларация метода БЕЗ имплементации. 
}

class Car(): IMy {
  function fire(){
    ...                 // имплементация, т.е. прописываем конкретный код
  }
}



## SOLID-4
ISP (Interface Segregation Principle / Принцип разделения интерфейса / Четвертый принцип SOLID) 
призывает не создавать жирные универсальные интерфейсы. 
Вместо этого интерфейсы нужно разделять на более мелкие и специализированные, 
это поможет гибче их комбинировать в имплементирующих классах, 
не заставляя имплементировать лишние методы.


# Абстракции
- почти четвертый остов ООП.
Но уместное количество абстрактных слоев порой трудно обозначить. ))

## Паттерны проектирования
- проверенные архитектурные решения.



# Ресурсы
https://habr.com/ru/post/463125/
https://habr.com/ru/post/136766/

https://doka.guide/js/oop
https://ota-solid.vercel.app/lsp/antipatterns
https://refactoring.guru/ru/design-patterns/state

